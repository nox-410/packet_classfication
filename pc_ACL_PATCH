diff --git a/bessctl/conf/pc_acl.bess b/bessctl/conf/pc_acl.bess
new file mode 100644
index 00000000..b668c01a
--- /dev/null
+++ b/bessctl/conf/pc_acl.bess
@@ -0,0 +1,58 @@
+import scapy.all as scapy
+
+# Craft a packet with the specified IP addresses
+def gen_packet(proto, src_ip, dst_ip):
+    eth = scapy.Ether(src='02:1e:67:9f:4d:ae', dst='06:16:3e:1b:72:32')
+    ip = scapy.IP(src=src_ip, dst=dst_ip)
+    udp = proto(sport=10001, dport=10002)
+    payload = 'helloworld'
+    pkt = eth/ip/udp/payload
+    return bytes(pkt)
+
+packets = [gen_packet(scapy.UDP, '172.16.100.1', '10.0.0.1'),
+           gen_packet(scapy.UDP, '172.12.55.99', '12.34.56.78'),
+           gen_packet(scapy.UDP, '172.12.55.99', '10.0.0.1'),
+           gen_packet(scapy.UDP, '172.16.100.1', '12.34.56.78'),
+           gen_packet(scapy.TCP, '172.12.55.99', '12.34.56.78'),
+           gen_packet(scapy.UDP, '192.168.1.123', '12.34.56.78'),
+          ]
+
+def get_rule_from_line(line):
+    L = list(line[1:].split())
+    sip = L[0]
+    dip = L[1]
+    sport_b, sport_e = int(L[2]), int(L[4])
+    dport_b, dport_e = int(L[5]), int(L[7])
+    prot , protmask = map(eval,L[8].split('/'))
+    prot_b = prot & protmask
+    prot_e = prot_b + (0xff ^ protmask)
+    return {'src_ip': sip,
+            'dst_ip': dip,
+            'drop': False,
+            'src_port_b': sport_b,
+            'src_port_e': sport_e,
+            'dst_port_b': dport_b,
+            'dst_port_e': dport_e,
+            'prot_b': prot_b,
+            'prot_e': prot_e}
+
+
+def get_rule_from_file(path):
+    f = open(path)
+    rule_array = []
+    while True:
+        line = f.readline()
+        if not line:
+            break
+        rule = get_rule_from_line(line)
+        rule_array.append(rule)
+    f.close()
+    return rule_array
+
+
+
+rule_number = 1024
+
+fw::PC_ACL(rules=get_rule_from_file("../../data/rule_{0}.rule".format(rule_number)))
+
+Source() -> Rewrite(templates=packets) -> fw -> Sink()
diff --git a/core/modules/pc_acl.cc b/core/modules/pc_acl.cc
new file mode 100644
index 00000000..096882fd
--- /dev/null
+++ b/core/modules/pc_acl.cc
@@ -0,0 +1,74 @@
+#include "pc_acl.h"
+
+#include "../utils/ether.h"
+#include "../utils/ip.h"
+#include "../utils/udp.h"
+
+const Commands PC_ACL::cmds = {
+    {"add", "PC_ACLArg", MODULE_CMD_FUNC(&PC_ACL::CommandAdd),
+     Command::THREAD_UNSAFE},
+    {"clear", "EmptyArg", MODULE_CMD_FUNC(&PC_ACL::CommandClear),
+     Command::THREAD_UNSAFE}};
+
+CommandResponse PC_ACL::Init(const bess::pb::PC_ACLArg &arg) {
+  for (const auto &rule : arg.rules()) {
+    ACLRule new_rule = {
+        .src_ip = Ipv4Prefix(rule.src_ip()),
+        .dst_ip = Ipv4Prefix(rule.dst_ip()),
+        .src_port_b = be16_t(static_cast<uint16_t>(rule.src_port_b())),
+        .src_port_e = be16_t(static_cast<uint16_t>(rule.src_port_e())),
+        .dst_port_b = be16_t(static_cast<uint16_t>(rule.dst_port_b())),
+        .dst_port_e = be16_t(static_cast<uint16_t>(rule.dst_port_e())),
+        .prot_b = be16_t(static_cast<uint16_t>(rule.prot_b())),
+        .prot_e = be16_t(static_cast<uint16_t>(rule.prot_e())),
+		.drop = rule.drop()};
+    rules_.push_back(new_rule);
+  }
+  return CommandSuccess();
+}
+
+CommandResponse PC_ACL::CommandAdd(const bess::pb::PC_ACLArg &arg) {
+  Init(arg);
+  return CommandSuccess();
+}
+
+CommandResponse PC_ACL::CommandClear(const bess::pb::EmptyArg &) {
+  rules_.clear();
+  return CommandSuccess();
+}
+
+void PC_ACL::ProcessBatch(Context *ctx, bess::PacketBatch *batch) {
+  using bess::utils::Ethernet;
+  using bess::utils::Ipv4;
+  using bess::utils::Udp;
+
+  gate_idx_t incoming_gate = ctx->current_igate;
+
+  int cnt = batch->cnt();
+  for (int i = 0; i < cnt; i++) {
+    bess::Packet *pkt = batch->pkts()[i];
+
+    Ethernet *eth = pkt->head_data<Ethernet *>();
+    Ipv4 *ip = reinterpret_cast<Ipv4 *>(eth + 1);
+    size_t ip_bytes = ip->header_length << 2;
+    Udp *udp =
+        reinterpret_cast<Udp *>(reinterpret_cast<uint8_t *>(ip) + ip_bytes);
+
+    bool emitted = false;
+    for (const auto &rule : rules_) {
+      if (rule.Match(ip->src, ip->dst, udp->src_port, udp->dst_port, eth->ether_type)) {
+        if (!rule.drop) {
+          emitted = true;
+          EmitPacket(ctx, pkt, incoming_gate);
+        }
+        break;  // Stop matching other rules
+      }
+    }
+
+    if (!emitted) {
+      DropPacket(ctx, pkt);
+    }
+  }
+}
+
+ADD_MODULE(PC_ACL, "pc_acl", "ACL module with five field")
diff --git a/core/modules/pc_acl.h b/core/modules/pc_acl.h
new file mode 100644
index 00000000..74ef7032
--- /dev/null
+++ b/core/modules/pc_acl.h
@@ -0,0 +1,47 @@
+#ifndef BESS_MODULES_PC_ACL_H_
+#define BESS_MODULES_PC_ACL_H_
+
+#include <vector>
+
+#include "../module.h"
+#include "../pb/module_msg.pb.h"
+#include "../utils/ip.h"
+
+using bess::utils::be16_t;
+using bess::utils::be32_t;
+using bess::utils::Ipv4Prefix;
+
+class PC_ACL final : public Module {
+ public:
+  struct ACLRule {
+    bool Match(be32_t sip, be32_t dip, be16_t sport, be16_t dport, be16_t prot) const {
+      return src_ip.Match(sip) && dst_ip.Match(dip) &&
+             sport >= src_port_b && sport <= src_port_e &&
+             dport >= dst_port_b && dport <= dst_port_e &&
+			 prot >= prot_b && prot <= prot_e;
+    }
+
+    Ipv4Prefix src_ip;
+    Ipv4Prefix dst_ip;
+	be16_t src_port_b,src_port_e;
+    be16_t dst_port_b,dst_port_e;
+	be16_t prot_b,prot_e;
+    bool drop;
+  };
+
+  static const Commands cmds;
+
+  PC_ACL() : Module() { max_allowed_workers_ = Worker::kMaxWorkers; }
+
+  CommandResponse Init(const bess::pb::PC_ACLArg &arg);
+
+  void ProcessBatch(Context *ctx, bess::PacketBatch *batch) override;
+
+  CommandResponse CommandAdd(const bess::pb::PC_ACLArg &arg);
+  CommandResponse CommandClear(const bess::pb::EmptyArg &arg);
+
+ private:
+  std::vector<ACLRule> rules_;
+};
+
+#endif  // BESS_MODULES_PC_ACL_H_
diff --git a/protobuf/module_msg.proto b/protobuf/module_msg.proto
index ef901a3e..af13c732 100644
--- a/protobuf/module_msg.proto
+++ b/protobuf/module_msg.proto
@@ -424,6 +424,21 @@ message ACLArg {
   repeated Rule rules = 1; ///A list of ACL rules.
 }
 
+message PC_ACLArg {
+  message Rule {
+    string src_ip = 1;    /// Source IP block in CIDR. Wildcard if "".
+    string dst_ip = 2;    /// Destination IP block in CIDR. Wildcard if "".
+    bool drop = 3;        /// Drop matched packets if true, forward if false. By default ACL drops all traffic.
+	uint32 src_port_b = 4;
+	uint32 src_port_e = 5;
+	uint32 dst_port_b = 6;
+	uint32 dst_port_e = 7;
+	uint32 prot_b = 8;
+	uint32 prot_e = 9;
+  }
+  repeated Rule rules = 1; ///A list of ACL rules.
+}
+
 /**
  * The BPF module is an access control module that sends packets out on a particular gate based on whether they match a BPF filter.
  *
